//didn't really have a place for this. Know it would get lost in the shuffle.
//TODO: Figure out
    void writeModulemap(File mainOut, String frameworkName) {

        //not writing to correct directory?
        def modulemapFile = new File(mainOut, "module.modulemap")

        FileWriter moduleMapWriter = new FileWriter(modulemapFile)

        String frameworkHeaderFilename = frameworkName + ".h"

        moduleMapWriter.append("module " + frameworkName + " {\n" +
                               "  umbrella header \"" + frameworkHeaderFilename + "\"\n" +
                               "\n" +
                               "  export *\n" +
                               "  module * { export * }\n" +
                               "}")

        moduleMapWriter.close();

        File frameworkHeaderFile = new File(mainOut, frameworkHeaderFilename)
        FileWriter headerWriter = new FileWriter(frameworkHeaderFile)

        headerWriter.append("#import <Foundation/Foundation.h>\n" +
                            "\n" +
                            "//! Project version number for " + frameworkName + ".\n" +
                            "FOUNDATION_EXPORT double " + frameworkName + "VersionNumber;\n" +
                            "\n" +
                            "//! Project version string for " + frameworkName + ".\n" +
                            "FOUNDATION_EXPORT const unsigned char " + frameworkName + "VersionString[];\n\n")

        def preTrimStart = mainOut.getAbsolutePath().length() + 1

        project.files(project.fileTree(
                dir: mainOut, includes: ["**/*.h"])).each { File f ->

            if (!frameworkHeaderFile.equals(f)) {

                String relativePath = f.getAbsolutePath().substring(preTrimStart)

                //You shouldn't be on windows, but if you are...
                relativePath = relativePath.replace('\\', '/')

                headerWriter.append("#import <" + relativePath + ">\n")
            }
        }

        headerWriter.close()
    }



    // Has task named afterTaskName depend on the task named beforeTaskName, regardless of
    // whether afterTaskName has been created yet or not.
    // The before task must already exist.
    private static void lateDependsOn(Project proj, String afterTaskName, String beforeTaskName) {
        assert null != proj.tasks.findByName(beforeTaskName)
        // You can't just call tasks.findByName on afterTaskName - for certain tasks like 'assemble' for
        // reasons unknown, the Java plugin creates - right there! - the task; this prevents
        // later code from modifying binaries, sourceSets, etc.  If you see an error
        // mentioning 'state GraphClosed' saying you can't mutate some object, see if you are magically
        // causing Gradle to make the task by using findByName!  Issue #156

        // tasks.all cleanly calls this closure on any existing elements and for all elements
        // added in the future.
        // TODO: Find a better way to have afterTask depend on beforeTask, without
        // materializing afterTask early.
        proj.tasks.all { Task task ->
            if (task.name == afterTaskName) {
                task.dependsOn beforeTaskName
            }
        }
    }