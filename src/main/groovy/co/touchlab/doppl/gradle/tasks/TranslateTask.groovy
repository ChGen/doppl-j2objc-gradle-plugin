/*

 */

package co.touchlab.doppl.gradle.tasks

import co.touchlab.doppl.gradle.DopplConfig
import co.touchlab.doppl.gradle.DopplDependency
import co.touchlab.doppl.gradle.analytics.DopplAnalytics
import groovy.transform.CompileStatic
import org.gradle.api.Action
import org.gradle.api.file.ConfigurableFileTree
import org.gradle.api.file.FileCollection
import org.gradle.api.file.FileTree
import org.gradle.api.internal.file.UnionFileCollection
import org.gradle.api.internal.file.UnionFileTree
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.InputDirectory
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.Optional
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.incremental.IncrementalTaskInputs
import org.gradle.api.tasks.incremental.InputFileDetails
import org.gradle.api.tasks.util.PatternSet

/**
 * Translation task for Java to Objective-C using j2objc tool.
 */
@CompileStatic
class TranslateTask extends BaseChangesTask {

    // Main java source files. May be generated by other tasks.
    @InputFiles
    FileCollection getSrcFiles() {
        List<FileTree> sourceSets =
                testBuild ?
                _buildContext.getBuildTypeProvider().testSourceSets(project)
                        :
                _buildContext.getBuildTypeProvider().sourceSets(project)
        return replaceOverlayFilterJava(sourceSets)
    }

    @Input
    Map<String, String> getTranslateSourceMapping() { return DopplConfig.from(project).translateSourceMapping }

    @InputDirectory @Optional
    File srcObjcDir;

    // Generated ObjC files
    @OutputDirectory
    File srcGenDir

    boolean testBuild

    //This is sort of an input, but should be covered by source file inputs
    Set<File> getSrcDirs() {
        Set<File> allFiles = new HashSet<>()
        for (FileTree genPath : _buildContext.getBuildTypeProvider().sourceSets(project)) {
            allFiles.add(Utils.dirFromFileTree(genPath))
        }
        if(testBuild)
        {
            for (FileTree genPath : _buildContext.getBuildTypeProvider().testSourceSets(project)) {
                allFiles.add(Utils.dirFromFileTree(genPath))
            }
        }
        return allFiles
    }

    List<DopplDependency> getTranslateDopplLibs() {
        List<DopplDependency> libs = new ArrayList<>()
        libs.addAll(_buildContext.getDependencyResolver().translateDopplLibs)
        if(testBuild)
        {
            libs.addAll(_buildContext.getDependencyResolver().translateDopplTestLibs)
        }
        return libs
    }

    private FileCollection replaceOverlayFilterJava(List<FileTree> sourceDirs) {

        FileTree allFiles = new UnionFileTree("asdf", (Collection<? extends FileTree>)sourceDirs)

        DopplConfig dopplConfig = DopplConfig.from(project)

        allFiles = allFiles.matching(new PatternSet().include("**/*.java"))

        List<String> overlaySourceDirs = dopplConfig.overlaySourceDirs
        Set<String> overlayClasses = new HashSet<>()
        List<FileTree> overlayTrees = new ArrayList<>()

        for (String sd  : overlaySourceDirs) {
            ConfigurableFileTree fileTree = project.fileTree(dir: sd, includes: ["**/*.java"])
            FileTree matchingFileTree = fileTree.matching(dopplConfig.translatePattern)

            for (File overlayFile : matchingFileTree.files) {
                overlayClasses.add(overlayFile.getPath().substring(fileTree.getDir().getPath().length()))
            }

            overlayTrees.add(matchingFileTree)
        }

        Set<File> allFilesFiles = allFiles.files
        Set<File> toRemove = new HashSet<>()

        //Yeah, this is not great. TODO: better matching algo
        for (File af : allFilesFiles) {

            String sourceFilePath = af.getPath()
            for (String overlayClassFilenameSuffix : overlayClasses) {
                if(sourceFilePath.endsWith(overlayClassFilenameSuffix))
                {
                    toRemove.add(af)
                }
            }
        }

        for (FileTree tree : overlayTrees) {
            allFiles.add(tree)
        }

        FileCollection resultCollection = allFiles;

        if (dopplConfig.translatePattern != null) {
            resultCollection = resultCollection.matching(dopplConfig.translatePattern)
        }

        resultCollection = resultCollection.filter {f ->
            !toRemove.contains(f)
        }

        return Utils.mapSourceFiles(project, resultCollection, getTranslateSourceMapping())
    }

    @TaskAction
    void translate(IncrementalTaskInputs inputs) {

        DopplConfig dopplConfig = DopplConfig.from(project)

        if(!dopplConfig.disableAnalytics) {
            new DopplAnalytics(dopplConfig, Utils.findVersionString(project, Utils.j2objcHome(project))).execute()
        }

        List<String> translateArgs = getTranslateArgs()

        // Don't evaluate this expensive property multiple times.
        FileCollection originalSrcFiles = getSrcFiles()

        FileCollection srcFilesChanged

        boolean forceFullBuild = !inputs.incremental
        srcFilesChanged = project.files()

        inputs.outOfDate(new Action<InputFileDetails>() {
            @Override
            void execute(InputFileDetails details) {

                if(forceFullBuild)
                    return

                // We must filter by srcFiles, since all possible input files are @InputFiles to this task.
                if (originalSrcFiles.contains(details.file)) {
                    srcFilesChanged += project.files(details.file)
                } else {
                    forceFullBuild = true
                }
            }
        })

        inputs.removed(new Action<InputFileDetails>() {
            @Override
            void execute(InputFileDetails details) {
                forceFullBuild = true
            }
        })

        println("forceFullBuild: "+ forceFullBuild + "/inputs.incremental: "+ inputs.incremental)

        if (forceFullBuild) {
            // A change outside of the source set directories has occurred, so an incremental build isn't possible.
            // The most common such change is in the JAR for a dependent library, for example if Java project
            // that this project depends on had its source changed and was recompiled.
            Utils.projectClearDir(project, srcGenDir)
            srcFilesChanged = originalSrcFiles
        }

        List<File> translateSourceDirs = new ArrayList<>(getSrcDirs());

        def prefixMap = getPrefixes()

        doTranslate(
                project.files(translateSourceDirs.toArray()),
                srcObjcDir,
                srcGenDir,
                translateArgs,
                prefixMap,
                srcFilesChanged,
                "mainSrcFilesArgFile",
                false,
                dopplConfig.emitLineDirectives
        )

        Utils.projectCopy(project, {
            from originalSrcFiles
            into srcGenDir
            setIncludeEmptyDirs(false)
            include '**/*.mappings'
        })

        if (prefixMap.size() > 0) {
            def prefixes = new File(srcGenDir, "prefixes.properties")
            def writer = new FileWriter(prefixes)

            Utils.propsFromStringMap(prefixMap).store(writer, null);

            writer.close()
        }
    }

    void recursiveGrab(File dir, List<File> files)
    {
        if(dir.isDirectory())
        {
            File[] dirFiles = dir.listFiles()
            for (File f : dirFiles) {
                if(f.isDirectory())
                    recursiveGrab(f, files)
                else if(f.getName().endsWith(".java"))
                    files.add(f);
            }
        }
    }

    void doTranslate(
            FileCollection sourcepathDirs,
            File nativeSourceDir,
            File srcDir,
            List<String> translateArgs,
            Map<String, String> prefixMap,
            FileCollection srcFilesToTranslate,
            String srcFilesArgFilename,
            boolean testTranslate,
            boolean emitLineDirectives) {

        if (nativeSourceDir != null && nativeSourceDir.exists()) {
            Utils.projectCopy(project, {
                includeEmptyDirs = false
                from nativeSourceDir
                into srcDir
            })
        }

        Set<File> files = srcFilesToTranslate.getFiles()
        int num = files.size()
        logger.info("Translating $num files with j2objc...")
        if (files.size() == 0) {
            logger.info("No files to translate; skipping j2objc execution")
            return
        }

        String j2objcExecutable = "${getJ2objcHome()}/j2objc"

        String sourcepathArg = Utils.joinedPathArg(sourcepathDirs)

        List<DopplDependency> dopplLibs = getTranslateDopplLibs()
        def libs = Utils.dopplJarLibs(dopplLibs)

        //Classpath arg for translation. Includes user specified jars, j2objc 'standard' jars, and doppl dependency libs
        UnionFileCollection classpathFiles = new UnionFileCollection([
                project.files(getTranslateClasspaths()),
                project.files(Utils.j2objcLibs(getJ2objcHome(), getTranslateJ2objcLibs())),
                project.files(libs)
        ])

        // TODO: comment explaining ${project.buildDir}/classes
        String classpathArg = Utils.joinedPathArg(classpathFiles) +
                              Utils.pathSeparator() + "${project.buildDir}/classes"

        // Source files arguments
        List<String> srcFilesArgs = []
        int srcFilesArgsCharCount = 0
        for (File file in srcFilesToTranslate) {
            String filePath = file.getPath()
            srcFilesArgs.add(filePath)
            srcFilesArgsCharCount += filePath.length() + 1
        }

        // Handle command line that's too long
        // Allow up to 2,000 characters for command line excluding src files
        // http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javac.html#commandlineargfile
        if (srcFilesArgsCharCount + 2000 > Utils.maxArgs()) {
            File srcFilesArgFile = new File(getTemporaryDir(), srcFilesArgFilename);
            FileWriter writer = new FileWriter(srcFilesArgFile);
            writer.append(srcFilesArgs.join('\n'));
            writer.close()
            // Replace src file arguments by referencing file
            srcFilesArgs = ["@${srcFilesArgFile.path}".toString()]
        }

        ByteArrayOutputStream stdout = new ByteArrayOutputStream()
        ByteArrayOutputStream stderr = new ByteArrayOutputStream()

        List<String> mappingFiles = new ArrayList<>()

        String path = mappingsInputPath()
        if (path != null) {
            mappingFiles.add(path);
        }

        Map<String, String> allPrefixes = new HashMap<>(prefixMap)

        for (DopplDependency lib : dopplLibs) {

            String mappingPath = Utils.findDopplLibraryMappings(lib.dependencyFolderLocation())
            if (mappingPath != null && !mappingPath.isEmpty()) {
                mappingFiles.add(mappingPath)
            }

            Properties prefixPropertiesFromFile = Utils.findDopplLibraryPrefixes(lib.dependencyFolderLocation())
            if (prefixPropertiesFromFile != null) {
                for (String name : prefixPropertiesFromFile.propertyNames()) {
                    allPrefixes.put(name, (String) properties.get(name))
                }
            }
        }

        try {
            Utils.projectExec(project, stdout, stderr, null, {
                executable j2objcExecutable

                // Arguments
                args "-d", srcDir
                if(emitLineDirectives)
                {
                    args "-g", ''
                }
//                args "--strip-reflection", ''
                args "-Xuse-javac", ''
                args "--package-prefixed-filenames", ''
                if (!testTranslate) {
                    args "--output-header-mapping", new File(srcDir, project.name + ".mappings").absolutePath
                }
                if (getIgnoreWeakAnnotations()) {
                    args "--ignore-weak-annotation", ''
                }
                if (mappingFiles.size() > 0) {
                    args "--header-mapping", mappingFiles.join(",")
                }
                args "-sourcepath", sourcepathArg
                args "-classpath", classpathArg
                translateArgs.each { String translateArg ->
                    args translateArg
                }

                allPrefixes.keySet().each { String packageString ->
                    args "--prefix", packageString + "=" + allPrefixes.get(packageString)
                }

                // File Inputs
                srcFilesArgs.each { String arg ->
                    // Can be list of src files or a single @/../srcFilesArgFile reference
                    args arg
                }

                setStandardOutput stdout
                setErrorOutput stderr
            })

        } catch (Exception exception) {  // NOSONAR
            // TODO: match on common failures and provide useful help
            throw exception
        }
    }
}
